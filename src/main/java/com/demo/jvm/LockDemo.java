package com.demo.jvm;

/**
 * @author chris
 * @create 2023/3/6
 */
public class LockDemo {
    /**
     * Java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，
     * 需要在户态与内核态之间切换，这种切换会消耗大量的系统资源，
     * 因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，
     * 用户态切换至内核态需要传递给许多变量、参数给内核，
     * 内核也需要保护好用户态在切换时的一些寄存器值、变量等，
     * 以便内核态调用结束后切换回用户态继续工作。
     * <p>
     * 在Java早期版本中，synchronized属于重量级锁，效率低下，
     * 因为监视器锁(monitor)是依赖于底层的操作系统的Mutex Lock(系统互斥量)来实现的，
     * 挂起线程和恢复线程都需要转入内核态去完成，
     * 阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状念切换需要耗费处理器时间，
     * 如果同步代码块中内容过于简单，这种切换的时问可能比用户代码执行的时间还长”，
     * 时间成本相对较高，这也是为什么早期的synchronized效率低的原因。
     * Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁。
     */
}
